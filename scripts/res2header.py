import argparse
import io
from itertools import zip_longest
import logging
import os
import sys

from PIL import Image
import pywavefront
pywavefront.configure_logging(logging.CRITICAL)

# Requirements:
# pillow
# pywavefront


def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)


def model2header(resource_file):
    name, ext = os.path.splitext(os.path.basename(resource_file))
    vertex_size = 0
    format = ''

    vertices = []
    model = pywavefront.Wavefront(resource_file)
    for _, material in model.materials.items():
        if material.vertex_format == 'V3F':
            format = 'VERTEX_FORMAT_POSITION'
            vertex_size = 3
        elif material.vertex_format == 'T2F_V3F':
            format = 'VERTEX_FORMAT_POSITION | VERTEX_FORMAT_TEXCOORD'
            vertex_size = 5
        elif material.vertex_format == 'N3F_V3F':
            format = 'VERTEX_FORMAT_POSITION | VERTEX_FORMAT_NORMAL'
            vertex_size = 6
        elif material.vertex_format == 'T2F_N3F_V3F':
            format = 'VERTEX_FORMAT_POSITION | VERTEX_FORMAT_TEXCOORD | VERTEX_FORMAT_NORMAL'
            vertex_size = 8
        else:
            raise SystemExit('Unknown model format: {}'.format(format))

        # group vertex attribs back to consistent order:
        # position, texcoord, normal
        for vertex in grouper(material.vertices, vertex_size):
            vertex = list(vertex)
            if material.vertex_format == 'V3F':
                position = vertex[0:3]
                vertices.extend(position)
            elif material.vertex_format == 'T2F_V3F':
                texcoord = vertex[0:2]
                position = vertex[2:5]
                vertices.extend(position)
                vertices.extend(texcoord)
            elif material.vertex_format == 'N3F_V3F':
                normal = vertex[0:3]
                position = vertex[3:6]
                vertices.extend(position)
                vertices.extend(normal)
            elif material.vertex_format == 'T2F_N3F_V3F':
                texcoord = vertex[0:2]
                normal = vertex[2:5]
                position = vertex[5:8]
                vertices.extend(position)
                vertices.extend(texcoord)
                vertices.extend(normal)

    count = len(vertices) // vertex_size
    guard = 'MODELS_{}_H_INCLUDED'.format(name.upper())

    s = io.StringIO()
    s.write('// THIS FILE WAS GENERATED BY:\n')
    s.write('// python3 ' + ' '.join(sys.argv) + '\n')
    s.write('#ifndef {}\n'.format(guard))
    s.write('#define {}\n'.format(guard))
    s.write('\n')
    s.write('#include "vertex.h"\n')
    s.write('\n')
    s.write('static const char MODELS_{}_PATH[] = "{}";\n'.format(name.upper(), resource_file))
    s.write('static const int MODELS_{}_VERTEX_FORMAT = {};\n'.format(name.upper(), format))
    s.write('static const long MODELS_{}_VERTEX_COUNT = {};\n'.format(name.upper(), count))
    s.write('static const float MODELS_{}_VERTICES[] = {{\n'.format(name.upper()))
    for group in grouper(vertices, vertex_size):
        group = list(group)
        while None in group:
            group.remove(None)
        line = ', '.join('{: f}f'.format(b) for b in group)
        s.write('    {},\n'.format(line))
    s.write('};\n')
    s.write('\n')
    s.write('#endif\n')

    return s.getvalue()


def shader2header(resource_file):
    name, ext = os.path.splitext(os.path.basename(resource_file))
    with open(resource_file) as f:
        source = f.read()

    guard = 'SHADERS_{}_H_INCLUDED'.format(name.upper())

    s = io.StringIO()
    s.write('// THIS FILE WAS GENERATED BY:\n')
    s.write('// python3 ' + ' '.join(sys.argv) + '\n')
    s.write('#ifndef {}\n'.format(guard))
    s.write('#define {}\n'.format(guard))
    s.write('\n')
    s.write('static const char SHADERS_{}_PATH[] = "{}";\n'.format(name.upper(), resource_file))
    s.write('static const char SHADERS_{}_SOURCE[] = \n'.format(name.upper()))
    for line in source.splitlines():
        s.write('    "{}\\n"\n'.format(line))
    s.write(';\n')
    s.write('\n')
    s.write('#endif\n')

    return s.getvalue()


def texture2header(resource_file):
    name, ext = os.path.splitext(os.path.basename(resource_file))

    # load image and flip vertically to accommodate OpenGL's texcoord system
    texture = Image.open(resource_file)
    texture = texture.transpose(Image.FLIP_TOP_BOTTOM)

    row_size = 0
    format = texture.mode
    if format == 'RGB':
        row_size = 12
        format = 'PIXEL_FORMAT_RGB'
    elif format == 'RGBA':
        row_size = 16
        format = 'PIXEL_FORMAT_RGBA'
    else:
        raise SystemExit('Unknown texture format: {}'.format(format))

    width, height = texture.size
    pixels = texture.tobytes()

    guard = 'TEXTURES_{}_H_INCLUDED'.format(name.upper())

    s = io.StringIO()
    s.write('// THIS FILE WAS GENERATED BY:\n')
    s.write('// python3 ' + ' '.join(sys.argv) + '\n')
    s.write('#ifndef {}\n'.format(guard))
    s.write('#define {}\n'.format(guard))
    s.write('\n')
    s.write('#include "pixel.h"\n')
    s.write('\n')
    s.write('static const char TEXTURES_{}_PATH[] = "{}";\n'.format(name.upper(), resource_file))
    s.write('static const int TEXTURES_{}_PIXEL_FORMAT = {};\n'.format(name.upper(), format))
    s.write('static const long TEXTURES_{}_WIDTH = {};\n'.format(name.upper(), width))
    s.write('static const long TEXTURES_{}_HEIGHT = {};\n'.format(name.upper(), height))
    s.write('static const unsigned char TEXTURES_{}_PIXELS[] = {{\n'.format(name.upper()))
    for group in grouper(pixels, row_size):
        group = list(group)
        while None in group:
            group.remove(None)
        line = ', '.join('0x{:02x}'.format(b) for b in group)
        s.write('    {},\n'.format(line))
    s.write('};\n')
    s.write('\n')
    s.write('#endif\n')

    return s.getvalue()


def res2header(resource_file):
    _, ext = os.path.splitext(os.path.basename(resource_file))
    if ext in ['.obj']:
        return model2header(resource_file)
    elif ext in ['.glsl']:
        return shader2header(resource_file)
    elif ext in ['.jpg', '.png']:
        return texture2header(resource_file)
    else:
        raise SystemExit('Unknown resource type: {}'.format(resource_file))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Convert game resources into C headers')
    parser.add_argument('resource_file', help='input resource file')
    parser.add_argument('header_file', help='output header file')
    args = parser.parse_args()

    header = res2header(args.resource_file)
    with open(args.header_file, 'w') as f:
        f.write(header)
